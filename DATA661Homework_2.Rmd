---
title: "DATA661 - Time Series Forecasting"
author: "Blandon Casenave"
date: "10/5/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, echo=TRUE, warning=FALSE}
library(ggplot2)
library(forecast)
library(tseries)
library(prophet)
library(stR)
library(zoo)
library(dplyr)
library(Metrics)
```
```{r, echo=FALSE, warning=FALSE}
Etraining<-"https://raw.githubusercontent.com/Misterresearch/DATA661/master/daily_demand_11-15.csv"
Etest<-"https://raw.githubusercontent.com/Misterresearch/DATA661/master/daily_demand_16.csv"

Etraining <- read.table(file = Etraining, header = TRUE, sep = ",", na.strings = c("","NA"))
Etraining$ds<-as.Date(Etraining$ds, "%m/%d/%Y")

Etest <- read.table(file = Etest, header = TRUE, sep = ",", na.strings = c("","NA"))
Etest$ds<-as.Date(Etest$ds, "%m/%d/%Y")
```


**Part I - summary statistics and a time series chart**

```{r, echo=FALSE, warning=FALSE}
summary(Etraining)

Etseries<-ts(Etraining$y, start=2011, end = 2016, frequency=365)
plot(Etseries)
```

**Part II - Forecast & Prophet decomposition charts for the raw data, seasonality and trend**

```{r, echo=FALSE, warning=FALSE}
# charts for the raw data, seasonality and trend
plot(decompose(na.approx(Etseries)))

m <- prophet(Etraining, daily.seasonality = TRUE)
summary(m)
future <- make_future_dataframe(m, periods = 366)
forecast <- predict(m, future)
plot(m, forecast)
prophet_plot_components(m, forecast)
```

**Part III - forecast data for 2016 ONLY in a data frame for subsequent analysis**

```{r, echo=FALSE, warning=FALSE}

#2016 data only, see part II for original data frame
prophet2016 <- forecast[ which(forecast$ds >'2015-12-31'), ]
plot(prophet2016$yhat)
```

**Part IV - stR Decomposition**

The Str & Propphet compoments depict a similar story when comparing the trends, seasonal and random error plots - that the data appears to be seaonal and somewhat stationary. 
```{r, echo=FALSE, warning=FALSE}

Etseries.msts <- msts(as.vector(Etraining$y), seasonal.periods = 365)
#Etseries.fit <- AutoSTR(Etseries.msts, gapCV = 7, confidence = .95)
#plot(Etseries.fit)

TrendSeasonalStructure <- list(segments=list(c(0,1)), 
                             sKnots = list(c(1,0)))
                             
TrendSeasons <- rep(1, nrow(Etraining))
Data <- as.vector(Etraining[,"y"])
Times <- as.vector(Etraining[,"ds"])
TrendTimeKnots <- seq(from = head(Times, 1), to = tail(Times, 1), length.out = 366)
TrendData <- rep(1, length(Times))

Trend <- list(name = "Trend", data = TrendData, times = Times, seasons = TrendSeasons, timeKnots = TrendTimeKnots, seasonalStructure = TrendSeasonalStructure, lambdas = c(1500,0,0))
Predictors <- list(Trend)

EtseriesSTR <- STR(data = Data, predictors = Predictors, confidence = .95, gapCV = 7)


plot(EtseriesSTR)
```

**Part V - Forecast package**

Forecast against test data set. na.approx was used to impute missing data points.

In order for ARIMA models to work, the data has to be stationary. A check of this, along with our visual inspection of the deasonalized trend shows that the data is stationary (adf test p-value of .05), tells us that we do not need differencing in this model. This data is seasonal. 

Following this, our (p,d,q) values that are generated by auto.arime() means that our "p" of 5 means that we have spikes at 5 "lags" or each of the periods/years in our Auto-Regressive (AR) model - (see ar1, ar2, ar3,ar4 & ar5 below). As we stated earlier, our p-value is .05, so this nets a differencing value of 1 in the AR model and 3 moving average lags (ma1, ma2, ma3).

```{r, echo=FALSE,warning=FALSE}
seasonalfit<- stl(na.approx(Etseries), s.window="periodic")
arimafit <- auto.arima(na.approx(Etseries), seasonal = TRUE)

#Is the data stationary
adf.test(na.approx(Etseries), alternative = "stationary")



seasonalforecast <-forecast(seasonalfit, h=366)
arimaforecast <- forecast(arimafit, h=366)
plot(seasonalforecast)
plot(arimaforecast)
plot(forecast(na.approx(Etseries), h=366))
```

**Part VI Actuals vs. Forecast for 2016**

Based on the RMSE, MAE & MSE being the lowest for the prophet forecast when compared to other methods (ARIMA, Seasonal) from the forecast package - I would say this model was the best peforming of the ones we tested. 

```{r, echo=FALSE}
AllForecast2016 <-(dplyr::mutate(Etest, ARIMAmean =(arimaforecast$mean), SeasonalMean=(seasonalforecast$mean), Prophet = (prophet2016$yhat)))
#accuracy(seasonalforecast)
#accuracy(arimaforecast)
#accuracy(forecast(na.approx(Etseries), h=366))

rmse(AllForecast2016$y, AllForecast2016$Prophet)
rmse(AllForecast2016$y, AllForecast2016$SeasonalMean)
rmse(AllForecast2016$y, AllForecast2016$ARIMAmean)

rmsematrix <- rbind(rmse(AllForecast2016$y, AllForecast2016$Prophet), rmse(AllForecast2016$y, AllForecast2016$SeasonalMean),rmse(AllForecast2016$y, AllForecast2016$ARIMAmean))
myRMSE <- data.frame(rmsematrix)
rownames(myRMSE) <- c("Prophet", "Seasonal", "ARIMA")


mae(AllForecast2016$y, AllForecast2016$Prophet)
mae(AllForecast2016$y, AllForecast2016$SeasonalMean)
mae(AllForecast2016$y, AllForecast2016$ARIMAmean)

maematrix <- rbind(mae(AllForecast2016$y, AllForecast2016$Prophet), mae(AllForecast2016$y, AllForecast2016$SeasonalMean),mae(AllForecast2016$y, AllForecast2016$ARIMAmean))
mymae <- data.frame(maematrix)
rownames(mymae) <- c("Prophet", "Seasonal", "ARIMA")


mse(AllForecast2016$y, AllForecast2016$Prophet)
mse(AllForecast2016$y, AllForecast2016$SeasonalMean)
mse(AllForecast2016$y, AllForecast2016$ARIMAmean)

msematrix <- rbind(mse(AllForecast2016$y, AllForecast2016$Prophet), mse(AllForecast2016$y, AllForecast2016$SeasonalMean),mse(AllForecast2016$y, AllForecast2016$ARIMAmean))
mymse <- data.frame(msematrix)
rownames(mymse) <- c("Prophet", "Seasonal", "ARIMA")

myRMSE
mymae
mymse
```

**Part VII - Additional Correlation Test**

Is a basic Pearson's R correlation test valid, when both variables are seasonal...does this make the comparison linear? 

```{r, echo=FALSE}
cor(AllForecast2016$y, AllForecast2016$Prophet)
cor(AllForecast2016$y, AllForecast2016$SeasonalMean)
cor(AllForecast2016$y, AllForecast2016$ARIMAmean)

cormatrix <- rbind(cor(AllForecast2016$y, AllForecast2016$Prophet), cor(AllForecast2016$y, AllForecast2016$SeasonalMean),cor(AllForecast2016$y, AllForecast2016$ARIMAmean))
mycor <- data.frame(cormatrix)
rownames(mycor) <- c("Prophet", "Seasonal", "ARIMA")
mycor
```


Sources: 
http://www.statmethods.net/advstats/timeseries.html

fill in missing data
https://stackoverflow.com/questions/24694558/seasonal-decompose-of-monthly-data-including-na-in-r

If data is seasonal then you must transform to MSTS before you can use AutoSTR
https://cran.r-project.org/web/packages/stR/vignettes/stRvignette.html

https://medium.com/towards-data-science/using-open-source-prophet-package-to-make-future-predictions-in-r-ece585b73687
